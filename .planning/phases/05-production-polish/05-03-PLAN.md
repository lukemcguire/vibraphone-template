---
phase: 05-production-polish
plan: 03
type: execute
wave: 2
depends_on:
  - "05-01"
  - "05-02"
files_modified:
  - src/main.go
  - src/crawler/crawler.go
  - src/crawler/worker.go
  - src/crawler/ratelimit.go
autonomous: true
requirements: []
user_setup: []

must_haves:
  truths:
    - "User can set delay between requests with --delay flag (ms instead of req/sec)"
    - "User can cap concurrency with --concurrency flag to disable auto-tune"
    - "Rate limiting adapts to server response times automatically"
    - "User can enable verbose network diagnostics with --verbose-network flag"
    - "Stricter of --delay or robots.txt Crawl-delay is applied"
  artifacts:
    - path: "src/crawler/ratelimit.go"
      provides: "Adaptive rate limiting based on RTT"
      exports: ["AdaptiveLimiter", "NewAdaptiveLimiter"]
    - path: "src/main.go"
      provides: "CLI flags for delay, concurrency, verbose-network"
      pattern: "flag\\.(IntVar|BoolVar)"
  key_links:
    - from: "src/crawler/crawler.go"
      to: "src/crawler/ratelimit.go"
      via: "AdaptiveLimiter replaces rate.Limiter"
      pattern: "AdaptiveLimiter"
    - from: "src/main.go"
      to: "src/crawler/crawler.go"
      via: "Config fields"
      pattern: "Delay|VerboseNetwork"
---

<objective>
Implement performance tuning with adaptive rate limiting and CLI flag changes for user control.

Purpose: Enable 50+ pages/second crawling with automatic adaptation while giving users explicit control when needed.
Output: Adaptive rate limiter, renamed --delay flag, --concurrency cap, and --verbose-network diagnostics.
</objective>

<execution_context>
@/home/luke/.claude/get-shit-done/workflows/execute-plan.md
@/home/luke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-production-polish/05-CONTEXT.md
@.planning/phases/05-production-polish/05-RESEARCH.md
@src/crawler/crawler.go
@src/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create adaptive rate limiter</name>
  <files>src/crawler/ratelimit.go</files>
  <action>
Create a new file `src/crawler/ratelimit.go` implementing adaptive rate limiting.

Per CONTEXT.md decision: "Auto-tune concurrency: dynamically adjust worker count based on server response times"

Implementation based on RESEARCH.md Pattern 2:
- Extend existing `golang.org/x/time/rate` usage with dynamic `SetLimit()` calls
- Use Exponential Moving Average (EMA) for RTT to avoid single slow response skewing
- Minimum rate floor (never below 5 RPS per CONTEXT.md pitfall #3)
- Gradual recovery (increase by 10% per good RTT)

Exported API:
```go
type AdaptiveLimiter struct { ... }

func NewAdaptiveLimiter(initialRPS int, targetRTT time.Duration) *AdaptiveLimiter
func (a *AdaptiveLimiter) Wait(ctx context.Context) error
func (a *AdaptiveLimiter) ObserveRTT(rtt time.Duration)  // Called after each request
func (a *AdaptiveLimiter) SetRate(rps int)               // Manual override (from --concurrency)
func (a *AdaptiveLimiter) CurrentRate() int              // For progress display
```

Default target RTT: 200ms (adjust based on observed server performance)
Initial RPS: 10 (matches current default)
  </action>
  <verify>`go build ./...` compiles, ratelimit.go exports AdaptiveLimiter</verify>
  <done>AdaptiveLimiter with EMA-based rate adjustment complete</done>
</task>

<task type="auto">
  <name>Task 2: Rename --rate-limit to --delay with inverted semantics</name>
  <files>src/main.go, src/crawler/crawler.go, src/crawler/worker.go</files>
  <action>
Breaking change per CONTEXT.md: "Rename `--rate-limit` to `--delay` (breaking change) - Change semantics from req/sec to ms between requests"

Changes to `src/main.go`:
1. Rename cliFlags field: `rateLimit` → `delay`
2. Change flag: `--rate-limit` (requests/second) → `--delay` (milliseconds between requests)
3. Default: 100ms delay (equivalent to 10 req/sec)
4. Usage text: "delay between requests in milliseconds (default 100)"

Changes to `src/crawler/worker.go`:
1. Rename Config field: `RateLimit int` → `Delay int`
2. Update DefaultConfig(): `Delay: 100` (milliseconds)
3. Update comment: "Delay between requests in milliseconds"

Changes to `src/crawler/crawler.go`:
1. Rename Config field usage: `cfg.RateLimit` → `cfg.Delay`
2. Convert delay (ms) to rate for limiter: `rate.Limit(1000 / cfg.Delay)`
3. Update AdaptiveLimiter initialization with calculated initial RPS

The conversion: 10 req/sec = 100ms delay, 5 req/sec = 200ms delay, etc.
  </action>
  <verify>`go build ./...` compiles, --help shows --delay not --rate-limit</verify>
  <done>--rate-limit renamed to --delay with millisecond semantics</done>
</task>

<task type="auto">
  <name>Task 3: Add --concurrency flag and integrate adaptive limiter</name>
  <files>src/main.go, src/crawler/crawler.go</files>
  <action>
Add explicit concurrency control per CONTEXT.md: "Explicit `--concurrency` flag caps or disables auto-tune"

Changes to `src/main.go`:
1. The --concurrency flag already exists but only controls worker count
2. Add flag: `--disable-auto-tune` to disable adaptive rate limiting
3. When --disable-auto-tune is set, use fixed rate from --delay

Changes to `src/crawler/crawler.go`:
1. Replace `limiter *rate.Limiter` with `limiter *AdaptiveLimiter`
2. In New(): Create AdaptiveLimiter instead of rate.Limiter
3. In worker loop: After each request, call `c.limiter.ObserveRTT(rtt)`
4. Apply stricter of --delay or robots.txt Crawl-delay:
   - If robots.txt specifies Crawl-delay, use max(cfg.Delay, crawlDelay*1000)

The adaptive limiter should ramp up if server handles load well, back off if responses slow down.
  </action>
  <verify>`go build ./...` and `go test ./src/crawler/...` pass</verify>
  <done>AdaptiveLimiter integrated, --concurrency controls auto-tune cap</done>
</task>

<task type="auto">
  <name>Task 4: Add --verbose-network flag for diagnostics</name>
  <files>src/main.go, src/crawler/worker.go</files>
  <action>
Add verbose network diagnostics per CONTEXT.md: "Network errors: add `--verbose-network` flag for detailed diagnostics (DNS, timeout, connection refused)"

Changes to `src/main.go`:
1. Add cliFlags field: `verboseNetwork bool`
2. Add flag: `--verbose-network` (bool, default false)
3. Pass to Config: `VerboseNetwork: opts.verboseNetwork`

Changes to `src/crawler/worker.go`:
1. Add Config field: `VerboseNetwork bool`
2. When VerboseNetwork is true and an error occurs:
   - Include full error chain with context
   - For DNS errors: show hostname, DNS server if available
   - For timeouts: show configured timeout vs actual duration
   - For connection refused: show host:port
3. When VerboseNetwork is false (default): simple error messages as currently implemented

Error message format for verbose mode:
- DNS: "DNS lookup failed for example.com: no such host"
- Timeout: "Request timed out after 10s (target: 200ms)"
- Connection: "Connection refused to example.com:443"

Per CONTEXT.md: "Style: minimal by default, trust user to investigate"
  </action>
  <verify>`go build ./...` compiles, --verbose-network flag available</verify>
  <done>--verbose-network flag enables detailed network error diagnostics</done>
</task>

</tasks>

<verification>
1. Run `go build ./...` - must compile without errors
2. Run `go test ./src/crawler/...` - all tests must pass
3. Run `./zombiecrawl --help` - shows --delay (not --rate-limit), --verbose-network
4. Verify AdaptiveLimiter is used in crawler
5. Verify delay semantics are milliseconds not req/sec
</verification>

<success_criteria>
- --rate-limit renamed to --delay with millisecond semantics (breaking change)
- AdaptiveLimiter adjusts rate based on server response times
- --concurrency flag caps/disables auto-tune
- --verbose-network flag enables detailed error diagnostics
- All existing tests pass
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-production-polish/05-03-SUMMARY.md`
</output>
